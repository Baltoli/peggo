/** @file */

#ifndef PARSE_TREE_H
#define PARSE_TREE_H

#include <stddef.h>

/**
 * Represents the result of a parse as a tree structure.
 *
 * This structure owns all of the child nodes it contains.
 */
typedef struct parse_st {
  /**
   * The symbol this node represents.
   *
   * If this node is a non-terminal, this is the non-terminal name. If it is a
   * terminal, then the symbol is the literal string matched.
   */
  char *symbol;

  /**
   * The offset into the source string at which this parse result begins.
   */
  size_t start;

  /**
   * The length of this parse result.
   *
   * This field is not valid if this node is a non-terminal whose children have
   * not yet been added. Once all children of this node are added, then the
   * length can be computed and stored properly by calling \ref
   * parse_total_length.
   */
  size_t length;

  /**
   * The child nodes for this node.
   *
   * This field is only used if the node is a non-terminal. In this case, the
   * child nodes are those generated by the production rule for this
   * non-terminal.
   */
  struct parse_st *children;

  /**
   * The number of child nodes this result has.
   */
  size_t n_children;
} parse_t;

/**
 * Construct a node in a parse tree.
 *
 * This constructor copies the string \p s, so does not take ownership.
 *
 * \param s The symbol for this node
 * \param st The starting offset of this node
 * \param len The length of this node's parse result
 */
parse_t *parse_init(char *s, size_t st, size_t len);

/**
 * Recursively free a parse result.
 *
 * This will free all child parses.
 *
 * \param tree The parse tree to be freed
 */
void parse_free(parse_t *tree);

/**
 * Add a new child node to a parse tree.
 *
 * This allocates memory for another child node in the tree, and performs a
 * *shallow copy* of \p child into this memory. The node \p child should not be
 * used after it has been passed to this method.
 *
 * \param tree The tree to add a child to
 * \param child The child node to be added
 */
void parse_add_child(parse_t *tree, parse_t *child);

/**
 * Pretty-print a parse tree to `STDOUT` at the specified indentation level.
 *
 * The indentation format is specified by \ref print_indents.
 *
 * \param tree The parse tree to be printed
 * \param indent The level of indentation
 */
void print_parse_indented(parse_t *tree, int indent);

/**
 * Pretty-print a parse tree to `STDOUT`.
 * 
 * \param tree The parse tree to be printed
 */
void print_parse(parse_t *tree);

/**
 * Compute the total length of a parse result by summing over its children's
 * lengths.
 *
 * This method should be used when the length of a \ref parse_t is not known at
 * the time it is constructed (for example, if it is being passed as a parent
 * node to the parser).
 *
 * \param tree The parse tree to compute length for
 */
size_t parse_total_length(parse_t *tree);

/**
 * Get a pointer to the first non-terminal child node of the given tree.
 *
 * If there are no such children, then the returned pointer will be equal to the
 * end pointer returned by `parse_non_terminal_end`.
 *
 * \param tree The parse tree to look for non-terminals in
 */
parse_t *parse_non_terminal_begin(parse_t *tree);

/**
 * Get a pointer to the end of the non-terminal children for the given tree.
 *
 * This pointer may not point to allocated memory and as such should never be
 * dereferenced (only checked for equality with one that has been advanced
 * through the non-terminals for a tree).
 *
 * \param tree The parse tree to look for non-terminals in
 */
parse_t *parse_non_terminal_end(parse_t *tree);

/**
 * Advance a pointer through the non-terminal children of a parse tree.
 *
 * If the child tree given is the last one, the return value of this function
 * will be the same as `parse_non_terminal_end`.
 *
 * \param tree The parent tree
 * \param child The current child pointer to be advanced
 */
parse_t *parse_non_terminal_next(parse_t *tree, parse_t *child);

#endif
